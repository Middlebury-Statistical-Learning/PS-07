library(tidyverse)
library(broom)
# We'll predict the sex (binary) of 60K OkCupid users using only their height
# https://github.com/rudeboybert/okcupiddata
library(okcupiddata)
data("profiles")

# Data cleaning:
profiles <- profiles %>%
  tbl_df() %>%
  # Create binary outcome variable y:
  mutate(y=ifelse(sex=="f", 1, 0)) %>%
  # Remove heights below 50 inches:
  #filter(height>50) %>%
  # Add ID column:
  mutate(ID = 1:n()) %>%
  select(ID, sex, y, height, age) %>%
  # Remove all rows with NA missing values:
  na.omit()


#generate train data
profiles_train <- profiles %>%
  sample_frac(0.5)

#generate test data
profiles_test <- profiles %>%
  anti_join(profiles_train, by="ID")

#train model y = height + age
model_formula <- as.formula(y~height+age)
model_logistic <- glm(model_formula, data=profiles_train, family="binomial")


##### Part 1: ROC Curve corresponding to phat with random guesses ####

#generate phat by randomly sampling from 0-1000 and dividing by 1000
profiles_train_rand <- profiles_train %>%
  mutate(
    p_hat = runif(nrow(profiles_train), 0, 1000)/1000,
    p_hat = round(p_hat, 3)
  ) %>%
  select(y, p_hat)
View(profiles_train_rand)


library(ROCR)

# Compute ROC curve
pred <- prediction(predictions = profiles_train_rand$p_hat, labels = profiles_train_rand$y)
perf <- performance(pred, "tpr","fpr")

# Compute Area Under Curve
auc <- as.numeric(performance(pred,"auc")@y.values)
auc

# Plot ROC and AUC
plot(perf, main=paste("Area Under the Curve =", round(auc, 3)))
abline(c(0, 1), lty=2)

##### Part 2: ROC Curve corresponding to phat with model predictions ####

#generate phat with logistic model
profiles_train_perfect <- profiles_train %>%
  mutate(
    p_hat = predict(model_logistic, type="response"),
    p_hat = round(p_hat, 3)
  ) %>%
  select(y, p_hat)
View(profiles_train_perfect)

# Compute ROC curve
pred <- prediction(predictions = profiles_train_perfect$p_hat, labels = profiles_train_perfect$y)
perf <- performance(pred, "tpr","fpr")

# Compute Area Under Curve
auc <- as.numeric(performance(pred,"auc")@y.values)
auc

# Plot ROC and AUC
plot(perf, main=paste("Area Under the Curve =", round(auc, 3)))
abline(c(0, 1), lty=2)


##### Part 3: Find p* that minimizes some cost function ####

#The cost function should be: cost = 2*(# false neg) + (# false pos)

#generate df of false negatives from prediction (pred varaible)
#this corresponds to the number of false negatives generated by each p* value
false_negs <- pred@fn %>%
  data.frame() %>%
  tbl_df() 
colnames(false_negs) <- c('fn')
false_negs <- false_negs %>%
  mutate(ID = 1:n())

#generate df of number of false positives from prediction (pred varaible)
#this corresponds to the number of false positives generated by each p* value
false_pos <- pred@fp %>%
  data.frame() %>%
  tbl_df() 
colnames(false_pos) <- c('fp')
false_pos <- false_pos %>%
  mutate(ID = 1:n())

#generate df of p* values from prediction (pred varaible)
cutoffs <- pred@cutoffs %>%
  data.frame() %>%
  tbl_df()
colnames(cutoffs) <- c('pstar')
cutoffs <- cutoffs %>%
  mutate(ID = 1:n())

#merge dataframes
half_df <- merge(false_negs,false_pos,by=c("ID"))
full_df <- merge(half_df,cutoffs,by=c("ID"))

#calculate cost function
full_df <- full_df %>%
  mutate(cost=(2*fn) + fp)

#find the min cost
min_cost_row <- full_df %>%
  arrange(cost) %>%
  slice(1)

min_cost_row
min_cost_row$cost

#plot data
ggplot(full_df, aes(x = pstar, y = cost)) +geom_point()
